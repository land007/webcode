<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Webcode Audio Player</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: #1a1a2e;
    color: #eee;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    gap: 24px;
  }
  h1 { font-size: 1.4rem; opacity: 0.85; letter-spacing: 0.03em; }
  #status {
    font-size: 0.9rem;
    opacity: 0.6;
    min-height: 1.4em;
    text-align: center;
  }
  #toggle-btn {
    font-size: 2.5rem;
    padding: 18px 36px;
    border: none;
    border-radius: 50px;
    cursor: pointer;
    transition: background 0.2s, transform 0.1s;
    background: #2a5298;
    color: #fff;
    box-shadow: 0 4px 20px rgba(0,0,0,0.4);
  }
  #toggle-btn:hover { background: #3060b0; transform: scale(1.04); }
  #toggle-btn.active { background: #1a8a4a; }
  #toggle-btn.error  { background: #8a1a1a; }
  .hint {
    font-size: 0.78rem;
    opacity: 0.45;
    text-align: center;
    max-width: 320px;
    line-height: 1.6;
  }
  .codec-info {
    font-size: 0.75rem;
    opacity: 0.5;
    margin-top: -10px;
  }
</style>
</head>
<body>
<h1>ğŸ–¥ï¸ Webcode Desktop Audio</h1>
<button id="toggle-btn">ğŸ”‡ å¼€å¯éŸ³é¢‘</button>
<div id="status">ç‚¹å‡»æŒ‰é’®å¼€å§‹æ’­æ”¾å®¹å™¨æ¡Œé¢éŸ³é¢‘</div>
<p class="hint">æµè§ˆå™¨å®‰å…¨ç­–ç•¥è¦æ±‚ç”¨æˆ·ä¸»åŠ¨ç‚¹å‡»æ‰èƒ½æ’­æ”¾éŸ³é¢‘ã€‚<br>éŸ³é¢‘ç»ç”± PulseAudio â†’ WebSocket å®æ—¶ä¼ è¾“ï¼Œå»¶è¿Ÿçº¦ 50msã€‚</p>
<div class="codec-info" id="codec-info">Codec: <span id="codec-display">Opus</span> | å¸¦å®½: <span id="bandwidth-display">~64 Kbps</span></div>

<script>
(function () {
  'use strict';
  var SAMPLE_RATE = 44100;
  var CHANNELS = 2;
  var FRAME_TYPE_PCM = 0x0000;
  var FRAME_TYPE_OPUS = 0x0001;
  var MAX_DECODER_QUEUE = 3;

  var btn    = document.getElementById('toggle-btn');
  var status = document.getElementById('status');
  var codecDisplay = document.getElementById('codec-display');
  var bandwidthDisplay = document.getElementById('bandwidth-display');

  var audioCtx    = null;
  var ws          = null;
  var nextPlayTime = 0;
  var active      = false;
  var currentCodec = 'opus';

  // Opus decoder
  var audioDecoder = null;
  var decoderQueue = [];
  var decoderPending = 0;

  function setStatus(msg) { status.textContent = msg; }

  // Get codec from URL parameter
  function getAudioCodec() {
    var match = location.search.match(/audioCodec=([^&]+)/i);
    var codec = match ? match[1].toLowerCase() : 'opus';
    if (codec === 'opus' && typeof AudioDecoder === 'undefined') {
      console.warn('[audio-player] AudioDecoder not supported, falling back to PCM');
      return 'pcm';
    }
    return codec;
  }

  function updateCodecInfo() {
    if (currentCodec === 'opus') {
      codecDisplay.textContent = 'Opus (å‹ç¼©)';
      bandwidthDisplay.textContent = '~64 Kbps';
    } else {
      codecDisplay.textContent = 'PCM (æœªå‹ç¼©)';
      bandwidthDisplay.textContent = '~1.37 Mbps';
    }
  }

  function stopAudio() {
    active = false;
    btn.textContent = 'ğŸ”‡ å¼€å¯éŸ³é¢‘';
    btn.className = '';
    setStatus('å·²åœæ­¢');
    if (ws)        { ws.close(); ws = null; }
    if (audioDecoder) {
      try { audioDecoder.close(); } catch (e) {}
      audioDecoder = null;
    }
    if (audioCtx)  { audioCtx.close(); audioCtx = null; }
    decoderQueue = [];
    decoderPending = 0;
  }

  function initOpusDecoder() {
    if (typeof AudioDecoder === 'undefined') {
      console.error('[audio-player] AudioDecoder not supported');
      return false;
    }

    try {
      audioDecoder = new AudioDecoder({
        output: function(frame) {
          playDecodedFrame(frame);
        },
        error: function(e) {
          console.error('[audio-player] Decode error:', e);
          decoderPending--;
        }
      });

      audioDecoder.configure({
        codec: 'opus',
        sampleRate: 48000,  // Opus always uses 48kHz internally
        numberOfChannels: CHANNELS
      });

      console.log('[audio-player] Opus decoder initialized');
      return true;
    } catch (e) {
      console.error('[audio-player] Failed to initialize AudioDecoder:', e);
      return false;
    }
  }

  function playDecodedFrame(frame) {
    if (!audioCtx) {
      frame.close();
      decoderPending--;
      return;
    }

    // Convert AudioFrame to AudioBuffer
    var numFrames = frame.numberOfFrames;
    var numChannels = frame.numberOfChannels || CHANNELS;
    var frameSampleRate = frame.sampleRate || SAMPLE_RATE;

    // Create buffer with the frame's actual sample rate
    var buffer = audioCtx.createBuffer(numChannels, numFrames, frameSampleRate);

    // Use AudioFrame.copyTo() to copy data to our buffer
    for (var ch = 0; ch < numChannels; ch++) {
      var channelData = buffer.getChannelData(ch);

      // Get the correct allocation size for this plane
      var allocationSize = frame.allocationSize({planeIndex: ch});
      var destArray = new Float32Array(allocationSize / 4); // 4 bytes per float

      // Copy frame data to destination array
      frame.copyTo(destArray, {planeIndex: ch});

      // Copy only the actual frames (not the entire allocation)
      for (var i = 0; i < numFrames; i++) {
        channelData[i] = destArray[i];
      }
    }
    frame.close();
    decoderPending--;

    // Schedule playback
    var source = audioCtx.createBufferSource();
    source.buffer = buffer;
    source.connect(audioCtx.destination);

    var now = audioCtx.currentTime;
    if (nextPlayTime < now) nextPlayTime = now + 0.01;
    source.start(nextPlayTime);
    nextPlayTime += buffer.duration;

    // Process queued Opus packets
    processDecoderQueue();
  }

  function processDecoderQueue() {
    while (decoderQueue.length > 0 && decoderPending < MAX_DECODER_QUEUE) {
      var payload = decoderQueue.shift();
      decodeOpusPacket(payload);
    }
  }

  function decodeOpusPacket(payload) {
    if (!audioDecoder || decoderPending >= MAX_DECODER_QUEUE) {
      decoderQueue.push(payload);
      return;
    }

    try {
      var chunk = new EncodedAudioChunk({
        type: 'key',
        timestamp: 0,
        data: new Uint8Array(payload)
      });
      audioDecoder.decode(chunk);
      decoderPending++;
    } catch (e) {
      console.error('[audio-player] Opus decode error:', e);
    }
  }

  function handlePCMFrame(data) {
    if (!audioCtx) return;
    var raw = new Int16Array(data);
    var numFrames = raw.length / CHANNELS;
    if (numFrames < 1) return;

    var buffer = audioCtx.createBuffer(CHANNELS, numFrames, SAMPLE_RATE);
    for (var ch = 0; ch < CHANNELS; ch++) {
      var channelData = buffer.getChannelData(ch);
      for (var i = 0; i < numFrames; i++) {
        channelData[i] = raw[i * CHANNELS + ch] / 32768.0;
      }
    }

    var source = audioCtx.createBufferSource();
    source.buffer = buffer;
    source.connect(audioCtx.destination);

    var now = audioCtx.currentTime;
    if (nextPlayTime < now) { nextPlayTime = now + 0.01; }
    source.start(nextPlayTime);
    nextPlayTime += buffer.duration;
  }

  function handleOpusFrame(data) {
    if (!audioDecoder) {
      if (!initOpusDecoder()) {
        console.warn('[audio-player] Opus decoder failed, PCM mode required');
        currentCodec = 'pcm';
        updateCodecInfo();
        return;
      }
    }
    decodeOpusPacket(data);
  }

  function startAudio() {
    active = true;
    btn.textContent = 'â³ è¿æ¥ä¸­â€¦';
    btn.className = '';
    setStatus('æ­£åœ¨è¿æ¥ WebSocket éŸ³é¢‘æœåŠ¡â€¦');

    // Initialize codec
    currentCodec = getAudioCodec();
    updateCodecInfo();

    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)({
        sampleRate: SAMPLE_RATE,
      });
    } catch (e) {
      setStatus('é”™è¯¯ï¼šæ— æ³•åˆ›å»º AudioContext â€” ' + e.message);
      stopAudio();
      return;
    }

    // Initialize Opus decoder if needed
    if (currentCodec === 'opus') {
      if (!initOpusDecoder()) {
        currentCodec = 'pcm';
        updateCodecInfo();
        console.warn('[audio-player] Falling back to PCM codec');
      }
    }

    nextPlayTime = audioCtx.currentTime + 0.02;

    var protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
    var wsUrl = protocol + '//' + location.host + '/audio';
    try {
      ws = new WebSocket(wsUrl);
    } catch (e) {
      setStatus('é”™è¯¯ï¼šWebSocket è¿æ¥å¤±è´¥ â€” ' + e.message);
      stopAudio();
      return;
    }

    ws.binaryType = 'arraybuffer';

    ws.onopen = function () {
      btn.textContent = 'ğŸ”Š åœæ­¢éŸ³é¢‘';
      btn.className = 'active';
      setStatus('æ­£åœ¨æ’­æ”¾â€¦ (' + wsUrl + ')');
      // Send codec negotiation handshake
      try {
        ws.send(JSON.stringify({
          version: 2,
          codec: currentCodec,
          sampleRate: SAMPLE_RATE,
          channels: CHANNELS
        }));
      } catch (e) {
        console.error('[audio-player] Handshake send failed:', e);
      }
    };

    ws.onerror = function () {
      setStatus('é”™è¯¯ï¼šWebSocket è¿æ¥æ–­å¼€');
      btn.className = 'error';
      setTimeout(stopAudio, 2000);
    };

    ws.onclose = function () {
      if (active) {
        setStatus('è¿æ¥å·²å…³é—­');
        btn.className = 'error';
        setTimeout(stopAudio, 2000);
      }
    };

    ws.onmessage = function (event) {
      if (!audioCtx) return;

      // Parse binary message header: [FrameType: 2 bytes][Length: 2 bytes][Payload]
      var view = new DataView(event.data);
      if (event.data.byteLength < 4) return;

      var frameType = view.getUint16(0);
      var payloadLength = view.getUint16(2);

      if (event.data.byteLength < 4 + payloadLength) return;

      var payload = event.data.slice(4);

      if (frameType === FRAME_TYPE_OPUS) {
        handleOpusFrame(payload);
      } else if (frameType === FRAME_TYPE_PCM) {
        handlePCMFrame(payload);
      }
    };
  }

  btn.addEventListener('click', function () {
    if (active) { stopAudio(); } else { startAudio(); }
  });

  // Initialize codec info display
  updateCodecInfo();
})();
</script>
</body>
</html>
