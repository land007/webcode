<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Webcode Audio Player</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: #1a1a2e;
    color: #eee;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    gap: 24px;
  }
  h1 { font-size: 1.4rem; opacity: 0.85; letter-spacing: 0.03em; }
  #status {
    font-size: 0.9rem;
    opacity: 0.6;
    min-height: 1.4em;
    text-align: center;
  }
  #toggle-btn {
    font-size: 2.5rem;
    padding: 18px 36px;
    border: none;
    border-radius: 50px;
    cursor: pointer;
    transition: background 0.2s, transform 0.1s;
    background: #2a5298;
    color: #fff;
    box-shadow: 0 4px 20px rgba(0,0,0,0.4);
  }
  #toggle-btn:hover { background: #3060b0; transform: scale(1.04); }
  #toggle-btn.active { background: #1a8a4a; }
  #toggle-btn.error  { background: #8a1a1a; }
  .hint {
    font-size: 0.78rem;
    opacity: 0.45;
    text-align: center;
    max-width: 320px;
    line-height: 1.6;
  }
</style>
</head>
<body>
<h1>ğŸ–¥ï¸ Webcode Desktop Audio</h1>
<button id="toggle-btn">ğŸ”‡ å¼€å¯éŸ³é¢‘</button>
<div id="status">ç‚¹å‡»æŒ‰é’®å¼€å§‹æ’­æ”¾å®¹å™¨æ¡Œé¢éŸ³é¢‘</div>
<p class="hint">æµè§ˆå™¨å®‰å…¨ç­–ç•¥è¦æ±‚ç”¨æˆ·ä¸»åŠ¨ç‚¹å‡»æ‰èƒ½æ’­æ”¾éŸ³é¢‘ã€‚<br>éŸ³é¢‘ç»ç”± PulseAudio â†’ Opus 64kbps â†’ WebSocket å®æ—¶ä¼ è¾“ï¼Œå»¶è¿Ÿçº¦ 30msã€‚</p>

<script>
(function () {
  'use strict';
  var SAMPLE_RATE = 48000;  // Opus native rate
  var CHANNELS = 2;

  var btn    = document.getElementById('toggle-btn');
  var status = document.getElementById('status');

  var audioCtx       = null;
  var ws             = null;
  var nextPlayTime   = 0;
  var active         = false;
  var audioDecoder   = null;
  var opusTimestamp  = 0;
  var codecOpus      = false;

  function setStatus(msg) { status.textContent = msg; }

  function stopAudio() {
    active = false;
    codecOpus = false;
    opusTimestamp = 0;
    btn.textContent = 'ğŸ”‡ å¼€å¯éŸ³é¢‘';
    btn.className = '';
    setStatus('å·²åœæ­¢');
    if (audioDecoder) { try { audioDecoder.close(); } catch (e) {} audioDecoder = null; }
    if (ws)           { ws.close(); ws = null; }
    if (audioCtx)     { audioCtx.close(); audioCtx = null; }
  }

  // â”€â”€ Opus decoder via WebCodecs AudioDecoder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function initOpusDecoder(info) {
    if (!window.AudioDecoder) {
      console.warn('[audio-player] AudioDecoder not available, falling back to raw PCM');
      return;
    }
    var sr = info.sample_rate || 48000;
    var ch = info.channels || 2;
    setStatus('Opus ' + (info.bitrate / 1000) + 'kbps @ ' + sr + 'Hz â€” æ­£åœ¨æ’­æ”¾â€¦');

    if (audioDecoder) { try { audioDecoder.close(); } catch (e) {} }
    opusTimestamp = 0;

    audioDecoder = new AudioDecoder({
      output: function (audioData) {
        if (!audioCtx) { audioData.close(); return; }
        var numFrames   = audioData.numberOfFrames;
        var numChannels = audioData.numberOfChannels;
        var sampleRate  = audioData.sampleRate;
        var buffer = audioCtx.createBuffer(numChannels, numFrames, sampleRate);
        for (var c = 0; c < numChannels; c++) {
          var plane = new Float32Array(numFrames);
          audioData.copyTo(plane, { planeIndex: c, format: 'f32-planar' });
          buffer.copyToChannel(plane, c);
        }
        audioData.close();
        var source = audioCtx.createBufferSource();
        source.buffer = buffer;
        source.connect(audioCtx.destination);
        var now = audioCtx.currentTime;
        if (nextPlayTime < now) nextPlayTime = now + 0.005;
        source.start(nextPlayTime);
        nextPlayTime += buffer.duration;
      },
      error: function (e) { console.error('[audio-player] AudioDecoder error:', e); },
    });

    audioDecoder.configure({ codec: 'opus', sampleRate: sr, numberOfChannels: ch });
    codecOpus = true;
  }

  function startAudio() {
    active = true;
    btn.textContent = 'â³ è¿æ¥ä¸­â€¦';
    btn.className = '';
    setStatus('æ­£åœ¨è¿æ¥ WebSocket éŸ³é¢‘æœåŠ¡â€¦');

    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SAMPLE_RATE });
    } catch (e) {
      setStatus('é”™è¯¯ï¼šæ— æ³•åˆ›å»º AudioContext â€” ' + e.message);
      stopAudio();
      return;
    }

    nextPlayTime = audioCtx.currentTime + 0.02;

    var protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
    var wsUrl = protocol + '//' + location.host + '/audio';
    try {
      ws = new WebSocket(wsUrl);
    } catch (e) {
      setStatus('é”™è¯¯ï¼šWebSocket è¿æ¥å¤±è´¥ â€” ' + e.message);
      stopAudio();
      return;
    }

    ws.binaryType = 'arraybuffer';

    ws.onopen = function () {
      btn.textContent = 'ğŸ”Š åœæ­¢éŸ³é¢‘';
      btn.className = 'active';
      setStatus('å·²è¿æ¥ï¼Œç­‰å¾…éŸ³é¢‘æµâ€¦');
    };

    ws.onerror = function () {
      setStatus('é”™è¯¯ï¼šWebSocket è¿æ¥æ–­å¼€');
      btn.className = 'error';
      setTimeout(stopAudio, 2000);
    };

    ws.onclose = function () {
      if (active) {
        setStatus('è¿æ¥å·²å…³é—­');
        btn.className = 'error';
        setTimeout(stopAudio, 2000);
      }
    };

    ws.onmessage = function (event) {
      // Text frame: codec negotiation or control message
      if (typeof event.data === 'string') {
        var msg;
        try { msg = JSON.parse(event.data); } catch (e) { return; }
        if (msg.event === 'codec_info') { initOpusDecoder(msg); }
        return;
      }
      if (!audioCtx) return;
      if (codecOpus && audioDecoder && audioDecoder.state === 'configured') {
        // â”€â”€ Opus path â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        try {
          audioDecoder.decode(new EncodedAudioChunk({
            type: 'key',
            timestamp: opusTimestamp,
            data: event.data,
          }));
          opusTimestamp += 20000; // 20ms per frame in Âµs
        } catch (e) {
          console.error('[audio-player] decode error:', e);
        }
      } else {
        // â”€â”€ Fallback: raw PCM Int16 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        var raw = new Int16Array(event.data);
        var numFrames = raw.length / CHANNELS;
        if (numFrames < 1) return;
        var buffer = audioCtx.createBuffer(CHANNELS, numFrames, SAMPLE_RATE);
        for (var ch = 0; ch < CHANNELS; ch++) {
          var channelData = buffer.getChannelData(ch);
          for (var i = 0; i < numFrames; i++) {
            channelData[i] = raw[i * CHANNELS + ch] / 32768.0;
          }
        }
        var source = audioCtx.createBufferSource();
        source.buffer = buffer;
        source.connect(audioCtx.destination);
        var now = audioCtx.currentTime;
        if (nextPlayTime < now) nextPlayTime = now + 0.01;
        source.start(nextPlayTime);
        nextPlayTime += buffer.duration;
      }
    };
  }

  btn.addEventListener('click', function () {
    if (active) { stopAudio(); } else { startAudio(); }
  });
})();
</script>
</body>
</html>
